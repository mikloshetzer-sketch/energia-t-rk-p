<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EU energiaimport – interaktív térkép</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111; }
    #map { height: 72vh; width: 100%; }

    .bar{
      padding:10px 12px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;
      border-bottom:1px solid #e6e6e6; background:#fff; position:sticky; top:0; z-index:999;
    }
    select, button{ padding:6px 10px; }
    button{ cursor:pointer; border:1px solid #d0d7de; background:#fff; border-radius:8px; }
    button:hover{ background:#f6f8fa; }
    .note{ font-size:12px; opacity:.75; }
    .spacer{ flex:1; }

    .legend{
      background:#fff; padding:10px 12px; border-radius:10px; line-height:1.2;
      box-shadow:0 4px 18px rgba(0,0,0,.12);
      min-width: 190px;
    }
    .legend .title{ font-weight: 700; margin-bottom: 6px; }
    .legend .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:4px 0; }
    .swatch{ width:16px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,.08); }
    .legend .left{ display:flex; align-items:center; gap:8px; }
    .legend small{ opacity:.75; }

    .panel{ border-top:1px solid #e6e6e6; padding:12px; background:#fff; }
    .panel h3{ margin:0 0 8px 0; font-size:14px; }
    .panel .sub{ font-size:12px; opacity:.75; margin-bottom:10px; }

    table{ border-collapse:collapse; width:100%; max-width:980px; }
    th, td{ text-align:left; padding:8px 10px; border-bottom:1px solid #eee; font-size:13px; vertical-align:middle; }
    th{ font-size:12px; opacity:.8; text-transform:uppercase; letter-spacing:.02em; }
    .tag{ display:inline-block; font-size:11px; padding:2px 8px; border-radius:999px; background:#f2f4f7; margin-left:8px; }
    .muted{ opacity:.75; }
    tr.clickable{ cursor:pointer; }
    tr.clickable:hover{ background:#f7f9fc; }

    .spark {
      width: 160px; height: 18px;
      display: inline-block;
      vertical-align: middle;
    }
  </style>
</head>
<body>

  <div class="bar">
    <label>
      Mutató:
      <select id="metric">
        <option value="quantity_mt">Mennyiség (Mt)</option>
        <option value="value_eur_bn">Érték (€ mrd)</option>
      </select>
    </label>

    <label>
      Energiatípus:
      <select id="energyType">
        <option value="ALL">Összes</option>
      </select>
    </label>

    <button id="exportPng" title="Térkép exportálása PNG-be">PNG export</button>

    <span class="spacer"></span>
    <span class="note">Forrás: Eurostat / Comext – Q3 2025</span>
  </div>

  <div id="map"></div>

  <div class="panel">
    <h3 id="topTitle">TOP 5 beszállító</h3>
    <div class="sub" id="topSub">—</div>
    <div id="top5"></div>
    <div class="sub muted" style="margin-top:8px;">
      Tipp: kattints a TOP 5 listában egy országra → a térkép odaugrik és felnyitja az adatokat.
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>

  <script>
    // ======= Map (Canvas preferálás a biztos PNG exporthoz) =======
    const map = L.map('map', { preferCanvas: true }).setView([54, 15], 3);
    const canvasRenderer = L.canvas({ padding: 0.5 });

    // CORS-barát tile, hogy a canvas export ne "tainted" legyen
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '© OpenStreetMap • © CARTO',
      subdomains: 'abcd',
      crossOrigin: true
    }).addTo(map);

    let countriesGeoJSON = null;
    let energyRows = [];
    let layer = null;

    // ISO2 -> Leaflet layer (TOP listából zoomhoz)
    const isoLayerMap = new Map();
    // TOP fallback markerek
    const topFallbackMarkers = new Map();

    const metricSel = document.getElementById('metric');
    const typeSel   = document.getElementById('energyType');
    const topTitle = document.getElementById('topTitle');
    const topSub   = document.getElementById('topSub');
    const topBox   = document.getElementById('top5');
    const exportBtn = document.getElementById('exportPng');

    // ISO2 fallback mapping (név -> kód)
    const ISO_FALLBACK = {
      "UNITED STATES OF AMERICA":"US",
      "UNITED STATES":"US",
      "RUSSIA":"RU",
      "UNITED KINGDOM":"GB",
      "GREAT BRITAIN":"GB",
      "NORWAY":"NO",
      "QATAR":"QA",
      "ALGERIA":"DZ",
      "SAUDI ARABIA":"SA",
      "CHINA":"CN",
      "SOUTH KOREA":"KR",
      "IRAN":"IR",
      "VIETNAM":"VN",
      "VENEZUELA":"VE",
      "BOLIVIA":"BO",
      "TANZANIA":"TZ",
      "SYRIA":"SY",
      "CZECHIA":"CZ",
      "LIBYA":"LY",
      "LIBYAN ARAB JAMAHIRIYA":"LY",
      "KAZAKHSTAN":"KZ",
      "KAZAKSTAN":"KZ"
    };

    // Fallback koordináták, ha nincs polygon
    const CENTROID_FALLBACK = {
      "SA":[23.8859, 45.0792],
      "CN":[35.8617, 104.1954],
      "QA":[25.3548, 51.1839],
      "DZ":[28.0339, 1.6596],
      "NO":[60.4720, 8.4689],
      "US":[39.8283, -98.5795],
      "RU":[61.5240, 105.3188],
      "AE":[23.4241, 53.8478],
      "LY":[26.3351, 17.2283],
      "KZ":[48.0196, 66.9237]
    };

    // ======= Choropleth (fix 5 sáv) =======
    const CHORO_COLORS = ['#e8f1ff', '#bfd7ff', '#86b4ff', '#3f86ff', '#0b3fbf'];

    function num(x){
      const v = Number(String(x ?? '').replace(',', '.'));
      return Number.isFinite(v) ? v : null;
    }

    function buildIndex(rows){
      const idx = new Map();
      for (const r of rows){
        const iso2 = String(r.iso2 || '').trim().toUpperCase();
        const t = String(r.energy_type || '').trim();
        if (!iso2 || !t) continue;
        idx.set(iso2 + '|' + t, {
          iso2,
          country: String(r.country || iso2).trim(),
          energy_type: t,
          quantity_mt: num(r.quantity_mt),
          value_eur_bn: num(r.value_eur_bn)
        });
      }
      return idx;
    }

    function buildCountryNameMap(rows){
      const m = new Map();
      for (const r of rows){
        const iso2 = String(r.iso2 || '').trim().toUpperCase();
        const c = String(r.country || '').trim();
        if (iso2 && c && !m.has(iso2)) m.set(iso2, c);
      }
      return m;
    }

    function metricLabel(metric){
      return metric === 'value_eur_bn' ? 'Érték (€ mrd)' : 'Mennyiség (Mt)';
    }

    function formatMetric(v, metric){
      if (v == null) return '–';
      return metric === 'value_eur_bn'
        ? ('€' + v.toFixed(2) + ' mrd')
        : (v.toFixed(2) + ' Mt');
    }

    function noDataExplanation(chosenType){
      const t = chosenType === 'ALL' ? 'az adott energiatípus(ok)ban' : `(${chosenType})`;
      return `EU-import: nincs regisztrált szállítás ${t} a vizsgált időszakban (Q3 2025).`;
    }

    function computeForCountry(iso2, idx, metric, chosenType){
      if (!iso2) return { value:null, breakdown:[] };

      if (chosenType !== 'ALL'){
        const it = idx.get(iso2 + '|' + chosenType);
        return { value: it ? it[metric] : null, breakdown: it ? [it] : [] };
      }

      const items = [];
      for (const v of idx.values()) if (v.iso2 === iso2) items.push(v);
      if (items.length === 0) return { value:null, breakdown:[] };

      let sum = 0, any = false;
      for (const it of items){
        if (it[metric] != null){ sum += it[metric]; any = true; }
      }
      items.sort((a,b)=> (b[metric] ?? -Infinity) - (a[metric] ?? -Infinity));
      return { value: any ? sum : null, breakdown: items };
    }

    // Kvantilis küszöbök 5 sávhoz (q20/q40/q60/q80)
    function quantile(sortedVals, q){
      if (sortedVals.length === 0) return null;
      const pos = (sortedVals.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sortedVals[base + 1] === undefined) return sortedVals[base];
      return sortedVals[base] + rest * (sortedVals[base + 1] - sortedVals[base]);
    }

    function buildBreaks(values){
      const vs = values.filter(v => v != null).sort((a,b)=>a-b);
      if (vs.length === 0) return [0,0,0,0,0,0];
      const b1 = quantile(vs, 0.2);
      const b2 = quantile(vs, 0.4);
      const b3 = quantile(vs, 0.6);
      const b4 = quantile(vs, 0.8);
      const min = vs[0];
      const max = vs[vs.length-1];
      return [min, b1, b2, b3, b4, max];
    }

    function colorForValue(val, breaks){
      if (val == null || val === 0) return '#f6f7f9'; // "no data"
      if (val <= breaks[1]) return CHORO_COLORS[0];
      if (val <= breaks[2]) return CHORO_COLORS[1];
      if (val <= breaks[3]) return CHORO_COLORS[2];
      if (val <= breaks[4]) return CHORO_COLORS[3];
      return CHORO_COLORS[4];
    }

    function getTop5(idx){
      const metric = metricSel.value;
      const chosenType = typeSel.value;

      const isoSet = new Set();
      for (const v of idx.values()) isoSet.add(v.iso2);

      const totals = [];
      for (const iso2 of isoSet){
        const { value } = computeForCountry(iso2, idx, metric, chosenType);
        if (value != null && value > 0) totals.push([iso2, value]);
      }

      totals.sort((a,b)=> b[1] - a[1]);
      const top = totals.slice(0, 5);
      const topSet = new Set(top.map(x => x[0]));
      return { top, topSet };
    }

    function clearTopFallbackMarkers(){
      for (const m of topFallbackMarkers.values()) m.remove();
      topFallbackMarkers.clear();
    }

    function focusCountry(iso2){
      const lyr = isoLayerMap.get(iso2);
      if (lyr){
        try{
          map.fitBounds(lyr.getBounds(), { padding:[30,30] });
          lyr.openPopup();
          return;
        }catch(e){}
      }

      const latlng = CENTROID_FALLBACK[iso2];
      if (latlng){
        map.setView(latlng, 4);
        const m = topFallbackMarkers.get(iso2);
        if (m) m.openPopup();
        return;
      }

      alert('Ehhez az országhoz nem találok térképi objektumot és nincs fallback koordináta.');
    }

    // Mini oszlopdiagram (SVG) TOP 5-höz
    function sparkBarSvg(value, maxValue){
      const w = 160, h = 18;
      const pad = 2;
      const frac = (maxValue > 0) ? (value / maxValue) : 0;
      const barW = Math.max(2, Math.round((w - pad*2) * frac));
      return `
        <svg class="spark" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect x="0" y="0" width="${w}" height="${h}" rx="4" fill="#f2f4f7"></rect>
          <rect x="${pad}" y="${pad}" width="${barW}" height="${h - pad*2}" rx="3" fill="#0b3fbf"></rect>
        </svg>
      `;
    }

    function renderTop5(top, nameMap){
      const metric = metricSel.value;
      const chosenType = typeSel.value;
      const typeText = chosenType === 'ALL' ? 'Összes energiatípus' : chosenType;

      topTitle.textContent = 'TOP 5 beszállító';
      topSub.textContent = `${typeText} • ${metricLabel(metric)} • Q3 2025`;

      if (top.length === 0){
        topBox.innerHTML = `<div class="muted">Nincs megjeleníthető TOP lista a jelenlegi szűrőkkel.</div>`;
        return;
      }

      const maxV = Math.max(...top.map(x => x[1]));

      const rowsHtml = top.map(([iso2, v], i) => {
        const name = nameMap.get(iso2) || iso2;
        return `
          <tr class="clickable" data-iso2="${iso2}">
            <td><b>${i+1}.</b></td>
            <td><b>${name}</b> <span class="tag">${iso2}</span></td>
            <td>
              <b>${formatMetric(v, metric)}</b><br>
              ${sparkBarSvg(v, maxV)}
            </td>
          </tr>
        `;
      }).join('');

      topBox.innerHTML = `
        <table>
          <thead>
            <tr><th>#</th><th>Ország</th><th>${metricLabel(metric)} + trend</th></tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;

      topBox.querySelectorAll('tr.clickable').forEach(tr => {
        tr.addEventListener('click', () => {
          const iso2 = tr.getAttribute('data-iso2');
          focusCountry(iso2);
        });
      });
    }

    function renderLegend(breaks, metric){
      if (window._legend) window._legend.remove();

      const legend = L.control({position:'bottomright'});
      legend.onAdd = () => {
        const div = L.DomUtil.create('div', 'legend');

        function fmt(x){
          if (x == null) return '–';
          if (metric === 'value_eur_bn') return '€' + x.toFixed(2) + 'b';
          return x.toFixed(2) + ' Mt';
        }

        const rows = [
          {c: CHORO_COLORS[0], a: breaks[0], b: breaks[1]},
          {c: CHORO_COLORS[1], a: breaks[1], b: breaks[2]},
          {c: CHORO_COLORS[2], a: breaks[2], b: breaks[3]},
          {c: CHORO_COLORS[3], a: breaks[3], b: breaks[4]},
          {c: CHORO_COLORS[4], a: breaks[4], b: breaks[5]},
        ];

        div.innerHTML = `
          <div class="title">Choropleth (5 sáv)</div>
          <small>${metricLabel(metric)}</small>
          <div style="margin-top:8px">
            ${rows.map(r => `
              <div class="row">
                <div class="left">
                  <span class="swatch" style="background:${r.c}"></span>
                  <span>${fmt(r.a)} – ${fmt(r.b)}</span>
                </div>
              </div>
            `).join('')}
            <div class="row" style="margin-top:6px;">
              <div class="left">
                <span class="swatch" style="background:#f6f7f9"></span>
                <span class="muted">Nincs adat</span>
              </div>
            </div>
          </div>
        `;
        return div;
      };
      legend.addTo(map);
      window._legend = legend;
    }

    function render(){
      const metric = metricSel.value;
      const chosenType = typeSel.value;

      const idx = buildIndex(energyRows);
      const nameMap = buildCountryNameMap(energyRows);
      const { top, topSet } = getTop5(idx);

      // értékek a choropleth töréspontokhoz
      const values = [];
      const isoSetAll = new Set();
      for (const v of idx.values()) isoSetAll.add(v.iso2);
      for (const iso2 of isoSetAll){
        const { value } = computeForCountry(iso2, idx, metric, chosenType);
        if (value != null && value > 0) values.push(value);
      }
      const breaks = buildBreaks(values);

      isoLayerMap.clear();
      clearTopFallbackMarkers();
      if (layer) layer.remove();

      layer = L.geoJSON(countriesGeoJSON, {
        renderer: canvasRenderer,

        style: (feature) => {
          const p = feature.properties || {};
          const name = p.ADMIN || p.name || '';
          let iso2 = String(p.ISO_A2 || '').trim().toUpperCase();

          if (!iso2 || iso2 === '-99'){
            const key = String(name).toUpperCase();
            iso2 = ISO_FALLBACK[key] || '';
          }

          const { value } = computeForCountry(iso2, idx, metric, chosenType);
          const isTop = topSet.has(iso2);

          return {
            color: isTop ? '#000' : '#333',
            weight: isTop ? 2.5 : 1,
            fillColor: colorForValue(value, breaks),
            fillOpacity: 0.85
          };
        },

        onEachFeature: (feature, lyr) => {
          const p = feature.properties || {};
          const featureName = p.ADMIN || p.name || 'Ország';

          let iso2 = String(p.ISO_A2 || '').trim().toUpperCase();
          if (!iso2 || iso2 === '-99'){
            const key = String(featureName).toUpperCase();
            iso2 = ISO_FALLBACK[key] || '';
          }

          if (iso2 && !isoLayerMap.has(iso2)) isoLayerMap.set(iso2, lyr);

          const displayName = (iso2 && nameMap.get(iso2)) ? nameMap.get(iso2) : featureName;

          function tooltipHtml(detailed=false){
            const metric = metricSel.value;
            const chosenType = typeSel.value;
            const { value, breakdown } = computeForCountry(iso2, idx, metric, chosenType);

            const header = `<b>${displayName}</b> <span class="tag">${iso2 || '—'}</span>`;

            if (!iso2){
              return `${header}<br><span class="muted">Nincs országkód, ezért nem párosítható az adattal.</span>`;
            }

            if (value == null || value === 0){
              return `${header}<br><span class="muted">${noDataExplanation(chosenType)}</span>`;
            }

            if (chosenType !== 'ALL'){
              return `${header}<br><b>${chosenType}</b>: ${formatMetric(value, metric)}`;
            }

            if (!detailed){
              const top2 = breakdown.slice(0,2)
                .map(it => `${it.energy_type}: ${formatMetric(it[metric], metric)}`)
                .join('<br>');
              return `${header}<br><b>Összes</b>: ${formatMetric(value, metric)}<br>${top2}`;
            } else {
              const lines = breakdown
                .map(it => `${it.energy_type}: <b>${formatMetric(it[metric], metric)}</b>`)
                .join('<br>');
              return `${header}<br><b>Összes</b>: ${formatMetric(value, metric)}<br><br>${lines}`;
            }
          }

          lyr.bindTooltip(() => tooltipHtml(false), { sticky:true, direction:'auto', opacity:0.95 });

          lyr.on('mouseover', () => lyr.setStyle({ weight: topSet.has(iso2) ? 3 : 2 }));
          lyr.on('mouseout',  () => lyr.setStyle({ weight: topSet.has(iso2) ? 2.5 : 1 }));

          lyr.on('click', () => {
            lyr.bindPopup(tooltipHtml(true)).openPopup();
          });
        }
      }).addTo(map);

      // Choropleth legenda (fix 5 sáv)
      renderLegend(breaks, metric);

      // TOP 5 panel + mini chart
      renderTop5(top, nameMap);

      // TOP fallback markerek (ha nincs polygon)
      for (const [iso2, v] of top){
        if (isoLayerMap.has(iso2)) continue;
        const latlng = CENTROID_FALLBACK[iso2];
        if (!latlng) continue;

        const m = L.circleMarker(latlng, {
          renderer: canvasRenderer,
          radius:7, color:'#000', weight:2, fillColor:'#0b3fbf', fillOpacity:0.95
        }).addTo(map)
          .bindPopup(`<b>${nameMap.get(iso2) || iso2}</b> <span class="tag">${iso2}</span><br>TOP 5 beszállító<br><b>${formatMetric(v, metricSel.value)}</b>`);

        topFallbackMarkers.set(iso2, m);
      }
    }

    async function loadAll(){
      const countriesUrl = 'https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson';
      const cRes = await fetch(countriesUrl);
      countriesGeoJSON = await cRes.json();

      await new Promise((resolve, reject) => {
        Papa.parse('./energy_data.csv', {
          download:true, header:true, skipEmptyLines:true,
          complete:(results)=>{ energyRows = results.data || []; resolve(); },
          error: reject
        });
      });

      const types = Array.from(new Set(
        energyRows.map(r => String(r.energy_type || '').trim()).filter(Boolean)
      )).sort();

      for (const t of types){
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        typeSel.appendChild(opt);
      }

      render();
    }

    metricSel.addEventListener('change', render);
    typeSel.addEventListener('change', render);

    // ======= PNG export (Canvas+idle) =======
    exportBtn.addEventListener('click', () => {
      exportBtn.disabled = true;
      exportBtn.textContent = 'Export...';

      const doExport = () => {
        setTimeout(() => {
          leafletImage(map, function(err, canvas) {
            exportBtn.disabled = false;
            exportBtn.textContent = 'PNG export';

            if (err || !canvas) {
              alert('Nem sikerült a PNG export. (Böngésző CORS/canvas korlátozás vagy renderelési hiba.)');
              return;
            }

            const a = document.createElement('a');
            const metric = metricSel.value;
            const type = typeSel.value;
            const ts = new Date().toISOString().slice(0,10);
            a.download = `eu-energy-map_${type}_${metric}_${ts}.png`;
            a.href = canvas.toDataURL('image/png');
            document.body.appendChild(a);
            a.click();
            a.remove();
          });
        }, 250);
      };

      map.once('idle', doExport);
      map.invalidateSize();
    });

    loadAll().catch(err => {
      console.error(err);
      alert('Hiba betöltés közben. Ellenőrizd, hogy az energy_data.csv a repó gyökerében van-e.');
    });
  </script>
</body>
</html>
